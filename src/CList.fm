//A Circular List 
// left is kept in reverse order 
// right is kept in order
type CList <A: Type> {
  nil,
  ring(left: List(A), focus: A, right: List(A))
}

type CList.Dir {
  Left,
  Right
}

// replaces the focus with the provided element, shifting
// the previous focus to the left
CList.add_left<A: Type>(a: A, cl: CList(A)): CList(A)
  case cl {
    nil : CList.singleton<_>(a),
    ring: CList.ring<_>(List.cons<_>(cl.focus, cl.left), a, cl.right)
  }

// replaces the focus with the provided element, shifting
// the previous focus to the right
CList.add_right<A: Type>(a: A, cl: CList(A)): CList(A)
  case cl {
   nil : CList.singleton<_>(a),
   ring: CList.ring<_>(cl.left, a, List.cons<_>(cl.focus, cl.right))
  }

CList.balance<A: Type>(cl: CList(A)): CList(A)
  CList.from_list<_>(CList.to_list<_>(cl))

CList.empty<A: Type> : CList(A)
  CList.nil<A>

CList.filter<A: Type>(p: A -> Bool, cl: CList(A)): CList(A)
  case cl {
    nil : cl,
    ring:  
      let list     = CList.to_list<_>(cl)
      let filtered = List.filter<_>(p, list) 
      CList.from_list<_>(filtered)
  }

CList.focus<A: Type>(cl: CList(A)): Maybe(A)
  case cl {
    nil : Maybe.none<_>,
    ring: Maybe.some<_>(cl.focus)
  }

CList.foldr<A: Type, B: Type>(b: B, f: A -> B -> B, cl: CList(A)): B
  let list = CList.to_list<_>(cl)
  List.foldr<_,_>(b, f, list)

// creates a balanced circular list from a regular list
CList.from_list<A: Type>(as: List(A)): CList(A)
  case as {
    nil : CList.nil<_>,
    cons: 
      let len = List.length<_>(as)
      let mid = Nat.div(len, 2)
      open List.split_at<_>(mid, as.tail) as spl
      let fst_half = spl.fst
      let snd_half = spl.snd
      CList.ring<_>(List.reverse<_>(snd_half), as.head, fst_half)
  }

CList.is_empty<A: Type>(cl: CList(A)): Bool
  case cl {
    nil : Bool.true,
    ring: Bool.false
  }

CList.left<A: Type>(cl: CList(A)): Maybe(List(A))
  case cl {
    nil : Maybe.none<_>,
    ring: Maybe.some<_>(cl.left)
  }

CList.length<A: Type>(cl: CList(A)): Nat
  case cl {
    nil : 0,
    ring:  
      let left  = List.length<A>(cl.left)
      let right = List.length<A>(cl.right)
      Nat.add(1, Nat.add(left, right))
  }

CList.map<A: Type, B: Type>(f: A -> B, cl: CList(A)): CList(B)
  case cl {
    nil : CList.nil<_>,
    ring:  
      let left  = List.map<_,_>(f, cl.left)
      let right = List.map<_,_>(f, cl.right)
      let focus = f(cl.focus)
      CList.ring<_>(left, focus, right)
  }

// removes the focus, replacing it with an element from the left
CList.remove_left<A: Type>(cl: CList(A)): CList(A)
  case cl {
    nil : cl,
    ring:  
    case cl.left {
      nil: case cl.right {
        nil : CList.nil<_>, //both right and left are empty
        cons: case List.reverse<_>(cl.right) as rev_right { //left is empty, right is not
          nil : CList.nil<_>, //unreachable
          cons: CList.ring<_>(rev_right.tail, rev_right.head, [])
        }             
      },    
      cons: CList.ring<_>(cl.left.tail, cl.left.head, cl.right)
    }
  }

// removes the focus, replacing it with an element from the right
CList.remove_right<A: Type>(cl: CList(A)): CList(A)
  case cl {
    nil : cl,
    ring: case cl.right {
      nil: case cl.left {
        nil : CList.nil<_>,  //both right and left are empty
        cons: case List.reverse<_>(cl.left) as rev_left { //right is empty, left is not
          nil : CList.nil<_>, //unreachable
          cons: CList.ring<_>([], rev_left.head, rev_left.tail)
        }             
      },  
      cons: CList.ring<_>(cl.left, cl.right.head, cl.right.tail)
    }
  }

CList.right<A: Type>(cl: CList(A)): Maybe(List(A))
  case cl {
    nil : Maybe.none<_>,
    ring: Maybe.some<_>(cl.right)
  }

// single anti-clockwise rotation
CList.rotate_left<A: Type>(cl: CList(A)): CList(A)
  case cl {
    nil : cl,
    ring: case cl.left {
      nil: case cl.right {
        //we have a singleton, nothing changes
        nil: cl, 
        // left is empty, right is not
        cons: case List.reverse<_>(cl.right) as rev_right {
          nil : cl, //unreachable
          cons:  
            let new_left  = rev_right.tail 
            let new_focus = rev_right.head 
            let new_right = [cl.focus]
            CList.ring<_>(new_left, new_focus, new_right)
        }
      },
      // left is not empty
      cons:  
        let new_left  = cl.left.tail 
        let new_focus = cl.left.head 
        let new_right = List.cons<_>(cl.focus, cl.right)
        CList.ring<_>(new_left, new_focus, new_right)
    } 
  }

CList.rotate_n<A: Type>(dir: CList.Dir, n: Nat, cl: CList(A)): CList(A)
  case dir {
    Left : Nat.apply<_>(n, CList.rotate_left<_>, cl),
    Right: Nat.apply<_>(n, CList.rotate_right<_>, cl)
  }

// single clockwise rotation 
CList.rotate_right<A: Type>(cl: CList(A)): CList(A)
  case cl {
    nil : cl,
    ring:  
    case cl.right {
      nil: case cl.left {
      //we have a singleton, nothing changes
        nil: cl,
      //right is empty, left is not
        cons: case List.reverse<_>(cl.left) as rev_left {
          nil : cl, //unreachable
          cons:
            let new_left  = [cl.focus]
            let new_focus = rev_left.head 
            let new_right = rev_left.tail 
            CList.ring<_>(new_left, new_focus, new_right)
        }
      },
    // right is not empty      
      cons:  
        let new_left  = List.cons<_>(cl.focus, cl.left)
        let new_focus = cl.right.head
        let new_right = cl.right.tail
        CList.ring<_>(new_left, new_focus, new_right)
    }
  }

CList.singleton<A: Type>(a: A): CList(A)
  CList.ring<_>([], a, [])

// converts a circular list into a regular one with the head as the focus
CList.to_list<A: Type>(cl: CList(A)): List(A)
  case cl {
    nil : List.nil<_>,
    ring:  
      let left  = List.reverse<_>(cl.left)
      let right = List.cons<_>(cl.focus, cl.right)
      List.concat<_>(right, left)
  }
